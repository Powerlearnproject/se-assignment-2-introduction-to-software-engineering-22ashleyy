1. Define Software Engineering:

Software Engineering - is the application of engineering principles to the development of software. It involves a systematic, disciplined, and quantifiable approach to the design, development, operation, and maintenance of software. The goal is to produce high-quality software that meets user requirements and is reliable, efficient, and maintainable.

2. What is software engineering, and how does it differ from traditional programming?

Software Engineering involves a comprehensive process that includes planning, designing, developing, testing, and maintaining software. It focuses on applying engineering principles and methodologies to ensure the software is scalable, maintainable, and reliable.

Traditional Programmingis primarily concerned with writing code to solve specific problems. It does not necessarily follow a structured process or consider the long-term maintenance and scalability of the software.
Differences:
Software engineering covers the entire software lifecycle, while traditional programming focuses mainly on coding.
Software engineering uses structured processes and methodologies; traditional programming often lacks these.
Software engineering aims for quality, scalability, and maintainability; traditional programming prioritizes immediate functionality.

3. Software Development Life Cycle (SDLC):

Phases of SDLC:

1. Planning:
   - Define project scope, objectives, feasibility, risks, and mitigation strategies.

2.Requirements Analysis:
   Gather and document all requirements from stakeholders and users.

3. Design:
   Create architecture and detailed design specifications for components, data structures, and algorithms.

4. Implementation:
   Write the actual code based on the design documents.

5. Testing:
   Test the software to find and fix defects. This includes unit, integration, system, and acceptance testing.

6. Deployment:
   Release the software to the production environment and train users.

7. Maintenance:
   Monitor and update the software as needed to fix issues and add new features.
 4. Agile vs. Waterfall Models:

Waterfall Model:

1. Sequential Phases: Each phase must be completed before the next one begins.
2. Documentation:Extensive documentation for each phase.
3. Rigid Structure: Little room for changes once a phase is completed.
4. Predictability:More predictable timelines and outcomes.
5. Drawbacks: Difficult to make changes, testing is done late.

Agile Model:

1. Iterative and Incremental: Breaks the project into small, iterative cycles.
2. Flexibility: Allows for changes in requirements even late in development.
3. Collaboration: Emphasizes teamwork and communication.
4. Customer Involvement: Continuous feedback from stakeholders.
5. Frequent Testing: Testing throughout the development cycle.

Key Differences:
- Flexibility: Agile is more flexible; Waterfall is more rigid.
- Testing: Agile tests throughout; Waterfall tests at the end.
- Documentation:Waterfall has extensive documentation; Agile has minimal documentation.

5. Requirements Engineering:
  Requirements Engineering - is the process of defining, documenting, and maintaining the requirements for a software system. It involves gathering input from stakeholders, analyzing needs, and specifying the requirements in a clear and detailed manner.

Importance:
 Ensures all stakeholders have a clear understanding of what the software should do.
 Reduces the risk of misunderstandings and errors.
 Provides a roadmap for developers and testers.
 Helps manage the project scope and avoid scope creep.

 6. Software Design Principles:
Dividing a software system into smaller, self-contained units (modules) that can be developed, tested, and maintained independently.
Improves maintainability, scalability, and reusability. Makes it easier to understand, develop, and test the software.

1. Unit Testing:
   Testing individual components or units of code.Ensures each unit functions correctly in isolation.

2. Integration Testing:
   Testing the interaction between integrated units.Detects issues in the interaction between units.

3. System Testing:
   Description: Testing the complete system as a whole.Ensures the system meets the specified requirements.

4. Acceptance Testing:
Testing the system with real-world scenarios and data.Verifies the system meets the business needs and is ready for deployment.

Importance of Testing:
Finds and fixes bugs early.
Verifies the software meets requirements.
 Fixing defects early is cheaper than fixing them after deployment.
Ensures the software is reliable and performs well.

8. Version Control Systems:
Tools that help manage changes to source code over time. They track revisions, allow collaboration, and help manage different versions of the software.

Importance:
Multiple developers can work on the same codebase.
Keeps a history of changes and allows reverting to previous versions.
Supports multiple development branches and merging changes.


9. Software Project Management:
Responsibilities: Planning, executing, and closing software projects. Managing resources, timelines, budgets, and risks. Communicating with stakeholders and ensuring project goals are met.
Challenges: Managing scope creep, handling changes in requirements, ensuring team collaboration, and meeting deadlines.

10. Software Maintenance:
The process of updating and improving software after it has been deployed.
Types:
  1. Corrective Maintenance: Fixing defects found after deployment.
  2. Adaptive Maintenance: Making the software work in new or changed environments.
  3. Perfective Maintenance: Enhancing the software to improve performance or maintainability.
  4. Preventive Maintenance: Updating the software to prevent future issues.

Importance:
Keeps the software relevant and functional.
Enhances performance and usability.
Addresses issues that were not discovered before deployment.

11. Ethical Considerations in Software Engineering:
Ensuring user data is protected and not misused.
Developing secure software to protect against threats.
Being honest about the software’s capabilities and limitations.
Taking responsibility for the software’s impact on users and society.
Sustainability:** Developing software that is environmentally and economically sustainable.





